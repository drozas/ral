package body http_10 is

   function HostValido10(Peticion: in Petition_Type;
                        Configuracion:in tInfoConfiguracion) return Boolean is
   --funcion auxiliar que determina si es válido el host de 1.0
   --DE MOMENTO SOLO COMPRUEBA EL DOMINIO POR DEFECTO!!!!
      EsValido:Boolean:=FALSE;
   begin
        if ASU.To_String(Peticion.Uri.Host)= ASU.To_String(Get_DominioPorDefecto(Configuracion))  then
           --Si el host del uri es el nuestro, es correcto...
           EsValido:=TRUE;
        elsif Peticion.Uri.Host=ASU.Null_Unbounded_String then
           --Vemos si existe campo host...
           if ExisteCampo(Peticion,ASU.To_Unbounded_String("Host")) then
                          --Si hay campo host, y coincide, es valido..
                if CoincideCampo(peticion,ASU.To_Unbounded_String("Host"),
                                 Get_DominioPorDefecto(Configuracion)) then
                EsValido:=TRUE;
                else
                --si existe, pero no coincide, es falso...
                EsValido:=FALSE;
                end if;
            else
                --Si no existe, damos por hecho que es bueno...
                EsValido:=TRUE;
            end if;

        end if;

        return EsValido;
   end HostValido10;

--------------------------------------------------------------------------------------------------------------

   procedure ComprobarCerrarConexion10(Peticion: in Petition_Type; FinConexion:out Boolean) is
   --funcion que determina si hay o no que cerrar la conexion (a traves del booleano) en 1.0
   begin
      --En http1.0, seguiremos solo  si hay un campo Connection: Keep-Alive
      ---Como lo controlamos al principio, si ocurre un BR despues, lo cambiara
      if ExisteCampo(Peticion,ASU.To_Unbounded_String("Connection")) and
        CoincideCampo(Peticion,ASU.To_Unbounded_String("Connection"),
                   ASU.To_Unbounded_String("Keep-Alive")) then
         FinConexion:=FALSE;
         Ada.Text_Io.Put_Line("CAMBIAMOS EL VALOR A FALSE, EN COMPROBARCERRARCONEX");
      else
         FinConexion:=TRUE;
         Ada.Text_Io.Put_Line("CAMBIAMOS EL VALOR A TRUE, EN COMPROBARCERRARCONEX");
      end if;
   end ComprobarCerrarConexion10;


-------------------------------------------------------------------------------------------------------
   procedure Attend_GET_Petition(Peticion: in Petition_Type;
                                 Conexion: in out TCP.Connection; Configuracion: in TInfoConfiguracion;
                                 FinConexion: out Boolean) is
   -- Procedimiento que implementa el metodo GET de version 1.0
      fichero: Ada.Streams.Stream_IO.File_Type;
      Acceso_Fichero:   Ada.Streams.Stream_IO.Stream_Access;
      car_Leido:character;
      cadena_leida:ASU.Unbounded_string;
      TamFichero: Natural;
      Ruta: ASU.Unbounded_String;
   begin


      Ada.Text_Io.Put_Line("Atendiendo peticion GET de HTTP 1.0");
      --Comprobacion del dominio (de momento sin acceso a ficheros)
      if HostValido10(Peticion,configuracion) then

         --Comprobamos por ultimo, si hay una cabecera que nos diga que tenemos que continuar
         ComprobarCerrarConexion10(Peticion,FinConexion);

         --Este bloque begin es para controlar si el fichero existe o no. Si no existe
         --levanta una excepcion de tipo Name_error que trataremos.
         --Comprobamos por ultimo, si hay una cabecera que nos diga que tenemos que continuar
         --LO PONEMOS EN EL PPO, A VER...
         --ComprobarCerrarConexion10(Peticion,FinConexion);
         begin
            --Formamos la ruta
            Ruta:="webdocs/" & Peticion.Uri.Path;
            Ada.Text_Io.Put_Line("Ruta del path: " & ASU.To_String(Ruta));
            SIO.Open(Fichero, SIO.In_File, ASU.To_String(Ruta));

            --Calculamos su tamaño, y preparamos la cabecera
            TamFichero := NATURAL(SIO.Size(fichero));
            Ada.Text_Io.Put_Line("Abriendo el archivo, y enviandolo. Devolveremos 200");
            String'Write(conexion'Access, CABECERA200_10 & End_Of_Header_Line);
            String'Write(conexion'access,"Content-Length: "& Natural'Image(TamFichero) & End_of_Header);

            --Accedemos al fichero
            Acceso_Fichero := SIO.Stream(Fichero);

            --Lectura y escritura(envio) del fichero..
            while not SIO.End_Of_File(fichero) loop
               character'Read(acceso_fichero,car_leido);
               Cadena_Leida:=Cadena_Leida & Car_Leido;
            end loop;

            String'write(conexion'access, ASU.to_string(Cadena_Leida));

            SIO.Close(Fichero);
         exception
            when SIO.Name_Error =>
               -- DEVOLVER MENSAJE 404
               Ada.Text_Io.Put_Line("El fichero pedido no existe. Devolvemos 404");
               String'Write(conexion'access,CABECERA404_10 & End_Of_Header);
         end;

      else
         --Si el host no es válido, devolvemos un error 400
         Ada.Text_Io.Put_Line("Host inválido. Devolveremos 400 (bad request de GET)");
         String'Write(conexion'access, CABECERA400_10 & End_Of_Header);
         --Cerramos la conexion forzosamente, por Bad Request
         FinConexion:=TRUE;
      end if;


   end Attend_GET_Petition;

---------------------------------------------------------------------------------------------------------

procedure Attend_HEAD_Petition(Peticion: in Petition_Type; Conexion: in out TCP.Connection;
                              Configuracion: in TInfoConfiguracion; FinConexion:out Boolean) is
      fichero: Ada.Streams.Stream_IO.File_Type;
      TamFichero: Natural;
      Ruta: ASU.Unbounded_String;
   begin

      Ada.Text_Io.PUt_Line("Atendiendo el get...");
      --Comprobacion del dominio (de momento sin acceso a ficheros)
      if HostValido10(Peticion,configuracion) then

         --Comprobamos por ultimo, si hay una cabecera que nos diga que tenemos que continuar
         ComprobarCerrarConexion10(Peticion,FinConexion);

         --Este bloque begin es para controlar si el fichero existe o no. Si no existe
         --levanta una excepcion de tipo Name_error que trataremos.
         --LO PONEMOS EN EL PPO, A VER...
         --ComprobarCerrarConexion10(Peticion,FinConexion);
         begin
            --Formamos la ruta
            Ruta:="webdocs/" & Peticion.Uri.Path;
            Ada.Text_Io.Put_Line("Ruta del path: " & ASU.To_String(Ruta));
            SIO.Open(Fichero, SIO.In_File, ASU.To_String(Ruta));
            --Calculamos su tamaño, y preparamos la cabecera
            TamFichero := NATURAL(SIO.Size(fichero));
            Ada.Text_Io.Put_Line("Abriendo el archivo, y enviandolo. Devolveremos 200");
            String'Write(conexion'Access, CABECERA200_10 & End_Of_Header_Line);
            String'Write(conexion'access,"Content-Length: "& Natural'Image(TamFichero) & End_of_Header);
            SIO.Close(Fichero);

         exception
            when SIO.Name_Error =>
               -- DEVOLVER MENSAJE 404
               Ada.Text_Io.Put_Line("El fichero pedido no existe. Devolvemos 404");
               String'Write(conexion'access,CABECERA404_10 & End_Of_Header);
         end;

      else
         --Si el host no es válido, devolvemos un error 400
         Ada.Text_Io.Put_Line("Host inválido. Devolveremos 400 (bad request del HEAD)");
         String'Write(conexion'access, CABECERA400_10 & End_Of_Header);
         --Cerramos la conexion forzosamente, por Bad Request
         FinConexion:=TRUE;

      end if;

   end Attend_HEAD_Petition;
----------------------------------------------------------------------------------------------------------


   procedure Attend_Petition_http10(Peticion: in Petition_Type; Conexion: in out TCP.Connection;
                                   Configuracion: in TInfoConfiguracion; FinConexion: out Boolean) is
   --Este procedimiento distribuye los metodos de tipo 1.0 de cada petición
   begin


      --De momento solo contempla los metodos GET y HEAD
      if Peticion.Method= Petition_Analysis.GET then
         Attend_GET_Petition(Peticion,Conexion,Configuracion,finConexion);
      elsif Peticion.Method= Petition_Analysis.HEAD then
         Attend_HEAD_Petition(Peticion,Conexion,Configuracion,finConexion);
      else
         String'Write(conexion'access, CABECERA501_10 & End_Of_Header);
         ADA.TEXT_IO.PUT_LINE("LLEGO AQUI?????");
         --Comprobamos por ultimo, si hay una cabecera que nos diga que tenemos que continuar
         ComprobarCerrarConexion10(Peticion,FinConexion);
         --FinConexion:=TRUE;
      end if;

   end Attend_Petition_Http10;

------------------------------------------------------------------------------------------------------


end http_10;
