package body http_11 is
------------------------------------------------------------------------------------------------------
   function HostValido11(Peticion: in Petition_Type;
                        Configuracion:in tInfoConfiguracion) return Boolean is
   --funcion auxiliar que determina si es válido el host de 1.1
   --DE MOMENTO SOLO COMPRUEBA EL DOMINIO POR DEFECTO!!!!
      EsValido:Boolean:=FALSE;
   begin
      if ExisteCampo(Peticion,ASU.To_Unbounded_String("Host")) then
         --Si no hay uri, miraremos en las cabeceras...
         if Peticion.Uri.Host=ASU.Null_Unbounded_String then
            --Y de momento en las cabeceras, solo mirarmos el de por defecto
            if CoincideCampo(Peticion,ASU.To_Unbounded_String("Host"),
                             Get_DominioPorDefecto(Configuracion)) then
               --Si coincide con el de por defecto, es correcto..
               EsValido:=TRUE;
            else
               EsValido:=FALSE;
            end if;
         else
            --Si hay uri, prevalece el del URI. De momento solo comparamos con el default
            if ASU.To_String(Peticion.Uri.Host)= ASU.To_String(Get_DominioPorDefecto(Configuracion)) then
               EsValido:=TRUE;
            else
               EsValido:=FALSE;
            end if;
         end if;

      else
         --En 1.1, debe existir campo host.Si no,el programa que le llama enviara BadRequest
         EsValido:=FALSE;
      end if;

      return EsValido;
   end HostValido11;

--------------------------------------------------------------------------------------------------------
   procedure ComprobarCerrarConexion11(Peticion: in Petition_Type; FinConexion: in out Boolean) is
      --Funcion que comprueba si hay cabeceras que indican el cierre de conexion, y lo devuelve
      -- a traves del booleano global

   begin
      --En http1.1, seguimos a no ser que haya un campo Connection:Close
      if ExisteCampo(Peticion,ASU.To_Unbounded_String("Connection")) and
        CoincideCampo(Peticion,ASU.To_Unbounded_String("Connection"),
                      ASU.To_Unbounded_String("Close")) then
         FinConexion:=TRUE;
         Ada.Text_Io.Put_Line("CAMBIAMOS EL VALOR A TRUE, EN COMPROBARCERRARCONEX");
      else
         FinConexion:=FALSE;
         Ada.Text_Io.Put_Line("CAMBIAMOS EL VALOR A FALSE, EN COMPROBARCERRARCONEX");
      end if;
   end ComprobarCerrarConexion11;

-------------------------------------------------------------------------------------------------------
   procedure Attend_GET_Petition(Peticion: in Petition_Type;
                                 Conexion: in out TCP.Connection; Configuracion: in TInfoConfiguracion;
                                 FinConexion:in out Boolean) is
   -- Procedimiento que implementa el metodo GET de version 1.0
      fichero: Ada.Streams.Stream_IO.File_Type;
      Acceso_Fichero:   Ada.Streams.Stream_IO.Stream_Access;
      car_Leido:character;
      cadena_leida:ASU.Unbounded_string;
      TamFichero: Natural;
      Ruta: ASU.Unbounded_String;
   begin

      Ada.Text_Io.Put_Line("Atendiendo peticion GET de HTTP 1.0");
      --Comprobacion del dominio (de momento sin acceso a ficheros)
      if HostValido11(Peticion,configuracion) then
                 --Este bloque begin es para controlar si el fichero existe o no. Si no existe
                 --levanta una excepcion de tipo Name_error que trataremos.
         begin
            --Formamos la ruta
                        Ruta:="webdocs/" & Peticion.Uri.Path;
            Ada.Text_Io.Put_Line("Ruta del path: " & ASU.To_String(Ruta));
            SIO.Open(Fichero, SIO.In_File, ASU.To_String(Ruta));

                        --Calculamos su tamaño, y preparamos la cabecera
            TamFichero := NATURAL(SIO.Size(fichero));
            Ada.Text_Io.Put_Line("Abriendo el archivo, y enviandolo. Devolveremos 200");
            String'Write(conexion'Access, CABECERA200_11 & End_Of_Header_Line);
            String'Write(conexion'access,"Content-Length: "& Natural'Image(TamFichero) & End_of_Header);

                        --Accedemos al fichero
            Acceso_Fichero := SIO.Stream(Fichero);

                        --Lectura y escritura(envio) del fichero..
            while not SIO.End_Of_File(fichero) loop
               character'Read(acceso_fichero,car_leido);
               Cadena_Leida:=Cadena_Leida & Car_Leido;
            end loop;

            String'write(conexion'access, ASU.to_string(Cadena_Leida));

            SIO.Close(Fichero);
         exception
            when SIO.Name_Error =>
               -- DEVOLVER MENSAJE 404
               Ada.Text_Io.Put_Line("El fichero pedido no existe. Devolvemos 404");
               String'Write(conexion'access,CABECERA404_11 & End_Of_Header);
         end;

         --Miramos si hay cabecera Close
         ComprobarCerrarConexion11(Peticion,FinConexion);
      else
         --Si el host no es válido, devolvemos un error 400
         Ada.Text_Io.Put_Line("Host inválido. Devolveremos 400 (bad request de GET)");
         String'Write(conexion'access, CABECERA400_11 & End_Of_Header);
         --Forzamos el cierre de conexion por BR, a traves del booleano global
         FinConexion:=TRUE;
      end if;

   end Attend_GET_Petition;

---------------------------------------------------------------------------------------------------------

procedure Attend_HEAD_Petition(Peticion: in Petition_Type; Conexion: in out TCP.Connection;
                              Configuracion: in TInfoConfiguracion; FinConexion: in out Boolean) is
      fichero: Ada.Streams.Stream_IO.File_Type;
      TamFichero: Natural;
      Ruta: ASU.Unbounded_String;
   begin

      Ada.Text_Io.PUt_Line("Atendiendo el get...");
      --Comprobacion del dominio (de momento sin acceso a ficheros)
      if HostValido11(Peticion,configuracion) then
                 --Este bloque begin es para controlar si el fichero existe o no. Si no existe
                 --levanta una excepcion de tipo Name_error que trataremos.
         begin
            --Formamos la ruta
                        Ruta:="webdocs/" & Peticion.Uri.Path;
            Ada.Text_Io.Put_Line("Ruta del path: " & ASU.To_String(Ruta));
            SIO.Open(Fichero, SIO.In_File, ASU.To_String(Ruta));
            --Calculamos su tamaño, y preparamos la cabecera
            TamFichero := NATURAL(SIO.Size(fichero));
            Ada.Text_Io.Put_Line("Abriendo el archivo, y enviandolo. Devolveremos 200");
            String'Write(conexion'Access, CABECERA200_11 & End_Of_Header_Line);
            String'Write(conexion'access,"Content-Length: "& Natural'Image(TamFichero) & End_of_Header);
            SIO.Close(Fichero);

         exception
            when SIO.Name_Error =>
               -- DEVOLVER MENSAJE 404
               Ada.Text_Io.Put_Line("El fichero pedido no existe. Devolvemos 404");
               String'Write(conexion'access,CABECERA404_11 & End_Of_Header);
         end;

         --Miramos si hay cabecera Close
         ComprobarCerrarConexion11(Peticion,FinConexion);
      else
         --Si el host no es válido, devolvemos un error 400
         Ada.Text_Io.Put_Line("Host inválido. Devolveremos 400 (bad request del HEAD)");
         String'Write(conexion'access, CABECERA400_11 & End_Of_Header);
         --Forzamos el cierre de conexion, a traves del booleano global
         FinConexion:=TRUE;

      end if;

   end Attend_HEAD_Petition;
----------------------------------------------------------------------------------------------------------


   procedure Attend_Petition_http11(Peticion: in Petition_Type; Conexion: in out TCP.Connection;
                                    Configuracion: in TInfoConfiguracion; FinConexion: in out Boolean) is
   --Este procedimiento distribuye los metodos de tipo 1.0 de cada petición

   begin

      --De momento solo contempla los metodos GET y HEAD
      if Peticion.Method= Petition_Analysis.GET then
         Attend_GET_Petition(Peticion,Conexion,Configuracion,finConexion);
      elsif Peticion.Method= Petition_Analysis.HEAD then
         Attend_HEAD_Petition(Peticion,Conexion,Configuracion,FinConexion);
      else
         String'Write(conexion'access, CABECERA501_11 & End_Of_header);
         --Miramos si hay cabecera Close
         ComprobarCerrarConexion11(Peticion,FinConexion);
      end if;

   end Attend_Petition_http11;

------------------------------------------------------------------------------------------------------

end http_11;
